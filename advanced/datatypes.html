<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Handy data types in the standard library</title>
    <link rel="stylesheet" type="text/css" href="../style.css">
  </head>
  <body>
    <a name="handy-data-types-in-the-standard-library" href="#handy-data-types-in-the-standard-library"><h1>Handy data types in the standard library</h1>
</a><p>Now we know how to use lists, tuples and dictionaries. They are commonly
used data types in Python, and there's nothing wrong with them. In this
chapter we'll learn more data types that make some things easier. You
can always do everything with lists and dictionaries, but these data
types can do a lot of the work for you.</p>
<blockquote><p>If it looks like a duck and quacks like a duck, it must be a duck.</p>
</blockquote>
<p>Many things in this tutorial are not really something but they behave
like something. For example, we'll learn about many classes that behave
like dictionaries. They are not dictionaries, but we can use them just
like if they were dictionaries. This programming style is known as
<strong>duck-typing</strong>.</p>
<a name="sets" href="#sets"><h2>Sets</h2>
</a><p>Let's say we have a program that keeps track of peoples' names. We can
store the names in <a href="../basics/lists-and-tuples.html">a list</a>, and adding a
new name is easy as appending to that list. Lists remember their order
and it's possible to add the same thing multiple times.</p>
<div class="highlight" style="background: #111111"><pre style="line-height: 125%; margin: 0;"><span></span>&gt;&gt;&gt; names = [<span style="color: #ffff33">&#39;wub_wub&#39;</span>, <span style="color: #ffff33">&#39;theelous3&#39;</span>, <span style="color: #ffff33">&#39;RubyPinch&#39;</span>, <span style="color: #ffff33">&#39;go|dfish&#39;</span>, <span style="color: #ffff33">&#39;Nitori&#39;</span>]
&gt;&gt;&gt; names.append(<span style="color: #ffff33">&#39;Akuli&#39;</span>)
&gt;&gt;&gt; names.append(<span style="color: #ffff33">&#39;Akuli&#39;</span>)
&gt;&gt;&gt; names
[&#39;wub_wub&#39;, &#39;theelous3&#39;, &#39;RubyPinch&#39;, &#39;go|dfish&#39;, &#39;Nitori&#39;, &#39;Akuli&#39;, &#39;Akuli&#39;]
&gt;&gt;&gt;
</pre></div>
<p>This is usually what we need, but sometimes it's not. Sometimes we just
want to store a bunch of things. We don't need to have the same thing
twice and we don't care about the order.</p>
<p>This is when sets come in. They are like lists without order or
duplicates, or keys of <a href="../basics/dicts.html">dictionaries</a> without the
values. We can create a set just like a dictionary, but without <code>:</code>.</p>
<div class="highlight" style="background: #111111"><pre style="line-height: 125%; margin: 0;"><span></span>&gt;&gt;&gt; names = {<span style="color: #ffff33">&#39;wub_wub&#39;</span>, <span style="color: #ffff33">&#39;theelous3&#39;</span>, <span style="color: #ffff33">&#39;RubyPinch&#39;</span>, <span style="color: #ffff33">&#39;go|dfish&#39;</span>, <span style="color: #ffff33">&#39;Nitori&#39;</span>}
&gt;&gt;&gt; names
{&#39;RubyPinch&#39;, &#39;theelous3&#39;, &#39;go|dfish&#39;, &#39;wub_wub&#39;, &#39;Nitori&#39;}
&gt;&gt;&gt; <span style="color: #9966ff">type</span>(names)
&lt;class &#39;set&#39;&gt;
&gt;&gt;&gt; <span style="color: #ffff33">&#39;wub_wub&#39;</span> in names
True
&gt;&gt;&gt;
</pre></div>
<p>We can also convert anything <a href="../basics/loops.html#summary">iterable</a> to a
set <a href="../basics/classes.html#what-are-classes">by calling the
class</a>.</p>
<div class="highlight" style="background: #111111"><pre style="line-height: 125%; margin: 0;"><span></span>&gt;&gt;&gt; <span style="color: #9966ff">set</span>(<span style="color: #ffff33">&#39;hello&#39;</span>)
{&#39;o&#39;, &#39;e&#39;, &#39;h&#39;, &#39;l&#39;}
&gt;&gt;&gt; <span style="color: #9966ff">type</span>(<span style="color: #9966ff">set</span>(<span style="color: #ffff33">&#39;hello&#39;</span>))
&lt;class &#39;set&#39;&gt;
&gt;&gt;&gt;
</pre></div>
<p>When we did <code>set('hello')</code> we lost one <code>l</code> and the set ended up in a
different order because sets don't contain duplicates or keep track of
their order.</p>
<p>Note that <code>{}</code> is a dictionary because dictionaries are used more often
than sets, so we need <code>set()</code> if we want to create an empty set.</p>
<div class="highlight" style="background: #111111"><pre style="line-height: 125%; margin: 0;"><span></span>&gt;&gt;&gt; <span style="color: #9966ff">type</span>({<span style="color: #ffff33">&#39;a&#39;</span>, <span style="color: #ffff33">&#39;b&#39;</span>})
&lt;class &#39;set&#39;&gt;
&gt;&gt;&gt; <span style="color: #9966ff">type</span>({<span style="color: #ffff33">&#39;a&#39;</span>})
&lt;class &#39;set&#39;&gt;
&gt;&gt;&gt; <span style="color: #9966ff">type</span>({})
&lt;class &#39;dict&#39;&gt;
&gt;&gt;&gt; <span style="color: #9966ff">type</span>(<span style="color: #9966ff">set</span>())     <span style="color: #336666; font-style: italic"># set() is an empty set</span>
&lt;class &#39;set&#39;&gt;
&gt;&gt;&gt;
</pre></div>
<p>Sets have a <code>remove</code> method just like lists have, but they have an <code>add</code>
method instead of <code>append</code>.</p>
<div class="highlight" style="background: #111111"><pre style="line-height: 125%; margin: 0;"><span></span>&gt;&gt;&gt; names = {<span style="color: #ffff33">&#39;theelous3&#39;</span>, <span style="color: #ffff33">&#39;wub_wub&#39;</span>}
&gt;&gt;&gt; names.add(<span style="color: #ffff33">&#39;Akuli&#39;</span>)
&gt;&gt;&gt; names
{&#39;wub_wub&#39;, &#39;Akuli&#39;, &#39;theelous3&#39;}
&gt;&gt;&gt; names.remove(<span style="color: #ffff33">&#39;theelous3&#39;</span>)
&gt;&gt;&gt; names
{&#39;wub_wub&#39;, &#39;Akuli&#39;}
&gt;&gt;&gt;
</pre></div>
<p>That's the boring part. Now let's have a look at some really handy
things we can do with sets:</p>
<div class="highlight" style="background: #111111"><pre style="line-height: 125%; margin: 0;"><span></span>&gt;&gt;&gt; a = {<span style="color: #ffff33">&#39;RubyPinch&#39;</span>, <span style="color: #ffff33">&#39;theelous3&#39;</span>, <span style="color: #ffff33">&#39;go|dfish&#39;</span>}
&gt;&gt;&gt; b = {<span style="color: #ffff33">&#39;theelous3&#39;</span>, <span style="color: #ffff33">&#39;Nitori&#39;</span>}
&gt;&gt;&gt; a &amp; b      <span style="color: #336666; font-style: italic"># names in a and b</span>
{&#39;theelous3&#39;}
&gt;&gt;&gt; a | b      <span style="color: #336666; font-style: italic"># names in a, b or both</span>
{&#39;Nitori&#39;, &#39;theelous3&#39;, &#39;go|dfish&#39;, &#39;RubyPinch&#39;}
&gt;&gt;&gt; a ^ b      <span style="color: #336666; font-style: italic"># names in a or b, but not both</span>
{&#39;RubyPinch&#39;, &#39;Nitori&#39;, &#39;go|dfish&#39;}
&gt;&gt;&gt; a - b      <span style="color: #336666; font-style: italic"># names in a but not in b</span>
{&#39;go|dfish&#39;, &#39;RubyPinch&#39;}
&gt;&gt;&gt;
</pre></div>
<a name="named-tuples" href="#named-tuples"><h2>Named tuples</h2>
</a><p>It can be tempting to make a class that just contains a bunch of data
and that's it.</p>
<div class="highlight" style="background: #111111"><pre style="line-height: 125%; margin: 0;"><span></span><span style="color: #6699cc; font-weight: bold">class</span> Website:

    <span style="color: #6699cc; font-weight: bold">def</span> __init__(<span style="color: #9966ff">self</span>, url, founding_year, free_to_use):
        <span style="color: #9966ff">self</span>.url = url
        <span style="color: #9966ff">self</span>.founding_year = founding_year
        <span style="color: #9966ff">self</span>.free_to_use = free_to_use


github = Website(<span style="color: #ffff33">&#39;https://github.com/&#39;</span>, 2008, <span style="color: #6699cc; font-weight: bold">True</span>)
</pre></div>
<p>You should avoid making classes like this. This class has only one
method, so it doesn't really need to be a class. We could just use a
tuple instead:</p>
<div class="highlight" style="background: #111111"><pre style="line-height: 125%; margin: 0;"><span></span>github = (<span style="color: #ffff33">&#39;https://github.com/&#39;</span>, 2008, <span style="color: #6699cc; font-weight: bold">True</span>)
</pre></div>
<p>The problem with this is that if someone reading our code sees something
like <code>website[1] &gt; 2010</code> it doesn't make much sense, like
<code>website.founding_year &gt; 2010</code> would.</p>
<p>In cases like this, <code>collections.namedtuple</code> is handy:</p>
<div class="highlight" style="background: #111111"><pre style="line-height: 125%; margin: 0;"><span></span>&gt;&gt;&gt; Website = collections.namedtuple(<span style="color: #ffff33">&#39;Website&#39;</span>, <span style="color: #ffff33">&#39;url founding_year free_to_use&#39;</span>)
&gt;&gt;&gt; github = Website(<span style="color: #ffff33">&#39;https://github.com/&#39;</span>, 2008, <span style="color: #6699cc; font-weight: bold">True</span>)
&gt;&gt;&gt; github[1]
2008
&gt;&gt;&gt; <span style="color: #6699cc; font-weight: bold">for</span> thing in github:
...     <span style="color: #9966ff">print</span>(thing)
...
https://github.com/
2008
True
&gt;&gt;&gt; github.founding_year
2008
&gt;&gt;&gt; github
Website(url=&#39;https://github.com/&#39;, founding_year=2008, free_to_use=True)
&gt;&gt;&gt;
</pre></div>
<p>As you can see, our <code>github</code> behaves like a tuple, but things like
<code>github.founding_year</code> also work and <code>github</code> looks nice when we have a
look at it on the <code>&gt;&gt;&gt;</code> prompt.</p>
<a name="deques" href="#deques"><h2>Deques</h2>
</a><p>To understand deques, we need to first learn about a list method I
haven't talked about earlier. It's called <code>pop</code> and it works like this:</p>
<div class="highlight" style="background: #111111"><pre style="line-height: 125%; margin: 0;"><span></span>&gt;&gt;&gt; names = [<span style="color: #ffff33">&#39;wub_wub&#39;</span>, <span style="color: #ffff33">&#39;theelous3&#39;</span>, <span style="color: #ffff33">&#39;Nitori&#39;</span>, <span style="color: #ffff33">&#39;RubyPinch&#39;</span>, <span style="color: #ffff33">&#39;go|dfish&#39;</span>]
&gt;&gt;&gt; names
[&#39;wub_wub&#39;, &#39;theelous3&#39;, &#39;Nitori&#39;, &#39;RubyPinch&#39;, &#39;go|dfish&#39;]
&gt;&gt;&gt; names.pop()
&#39;go|dfish&#39;
&gt;&gt;&gt; names
[&#39;wub_wub&#39;, &#39;theelous3&#39;, &#39;Nitori&#39;, &#39;RubyPinch&#39;]
&gt;&gt;&gt; names.pop()
&#39;RubyPinch&#39;
&gt;&gt;&gt; names
[&#39;wub_wub&#39;, &#39;theelous3&#39;, &#39;Nitori&#39;]
&gt;&gt;&gt;
</pre></div>
<p>The list shortens from the end by one when we pop from it, and we also
get the removed item back. So we can add an item to the end of a list
using <code>append</code>, and we can remove an item from the end using <code>pop</code>.</p>
<p>It's also possible to do these things in the beginning of a list, but
lists were not designed to be used that way and it would be slow if our
list would be big. The <code>collections.deque</code> class makes appending and
popping from both ends easy and fast. It works just like lists, but it
also has <code>appendleft</code> and <code>popleft</code> methods.</p>
<div class="highlight" style="background: #111111"><pre style="line-height: 125%; margin: 0;"><span></span>&gt;&gt;&gt; names = collections.deque([<span style="color: #ffff33">&#39;theelous3&#39;</span>, <span style="color: #ffff33">&#39;Nitori&#39;</span>, <span style="color: #ffff33">&#39;RubyPinch&#39;</span>])
&gt;&gt;&gt; names
deque([&#39;theelous3&#39;, &#39;Nitori&#39;, &#39;RubyPinch&#39;])
&gt;&gt;&gt; names.appendleft(<span style="color: #ffff33">&#39;wub_wub&#39;</span>)
&gt;&gt;&gt; names.append(<span style="color: #ffff33">&#39;go|dfish&#39;</span>)
&gt;&gt;&gt; names
deque([&#39;wub_wub&#39;, &#39;theelous3&#39;, &#39;Nitori&#39;, &#39;RubyPinch&#39;, &#39;go|dfish&#39;])
&gt;&gt;&gt; names.popleft()
&#39;wub_wub&#39;
&gt;&gt;&gt; names.pop()
&#39;go|dfish&#39;
&gt;&gt;&gt; names
deque([&#39;theelous3&#39;, &#39;Nitori&#39;, &#39;RubyPinch&#39;])
&gt;&gt;&gt;
</pre></div>
<p>The deque behaves a lot like lists do, and we can do <code>list(names)</code> if we
need a list instead of a deque for some reason.</p>
<p>Deques are often used as queues. It means that items are always added to
one end and popped from the other end.</p>
<a name="counting-things" href="#counting-things"><h2>Counting things</h2>
</a><p>Back in <a href="../basics/dicts.html#examples">the dictionary chapter</a> we learned
to count the number of words in a sentence like this:</p>
<div class="highlight" style="background: #111111"><pre style="line-height: 125%; margin: 0;"><span></span>sentence = <span style="color: #9966ff">input</span>(<span style="color: #ffff33">&quot;Enter a sentence: &quot;</span>)
counts = {}
<span style="color: #6699cc; font-weight: bold">for</span> word in sentence.split():
    <span style="color: #6699cc; font-weight: bold">if</span> word in counts:
        counts[word] += 1
    <span style="color: #6699cc; font-weight: bold">else</span>:
        counts[word] = 1
</pre></div>
<p>This code works just fine, but there are easier ways to do this. For
example, we could use the <code>get</code> method. It works so that
<code>the_dict.get('hi', 'hello')</code> tries to give us <code>the_dict['hi']</code> but
gives us <code>'hello'</code> instead if <code>'hi'</code> is not in the dictionary.</p>
<div class="highlight" style="background: #111111"><pre style="line-height: 125%; margin: 0;"><span></span>&gt;&gt;&gt; the_dict = {<span style="color: #ffff33">&#39;hi&#39;</span>: <span style="color: #ffff33">&#39;this is working&#39;</span>}
&gt;&gt;&gt; the_dict.get(<span style="color: #ffff33">&#39;hi&#39;</span>, <span style="color: #ffff33">&#39;lol its not there&#39;</span>)
&#39;this is working&#39;
&gt;&gt;&gt; the_dict.get(<span style="color: #ffff33">&#39;hello&#39;</span>, <span style="color: #ffff33">&#39;lol its not there&#39;</span>)
&#39;lol its not there&#39;
&gt;&gt;&gt;
</pre></div>
<p>So we could write code like this instead:</p>
<div class="highlight" style="background: #111111"><pre style="line-height: 125%; margin: 0;"><span></span>sentence = <span style="color: #9966ff">input</span>(<span style="color: #ffff33">&quot;Enter a sentence: &quot;</span>)
counts = {}
<span style="color: #6699cc; font-weight: bold">for</span> word in sentence.split():
    counts[word] = counts.get(word, 0) + 1
</pre></div>
<p>Counting things like this is actually so common that there's <a href="../basics/classes.html">a
class</a> just for that. It's called
<code>collections.Counter</code> and it works like this:</p>
<div class="highlight" style="background: #111111"><pre style="line-height: 125%; margin: 0;"><span></span>&gt;&gt;&gt; <span style="color: #6699cc; font-weight: bold">import</span> collections
&gt;&gt;&gt; words = [<span style="color: #ffff33">&#39;hello&#39;</span>, <span style="color: #ffff33">&#39;there&#39;</span>, <span style="color: #ffff33">&#39;this&#39;</span>, <span style="color: #ffff33">&#39;test&#39;</span>, <span style="color: #ffff33">&#39;is&#39;</span>, <span style="color: #ffff33">&#39;a&#39;</span>, <span style="color: #ffff33">&#39;hello&#39;</span>, <span style="color: #ffff33">&#39;test&#39;</span>]
&gt;&gt;&gt; counts = collections.Counter(words)
&gt;&gt;&gt; counts
Counter({&#39;test&#39;: 2, &#39;hello&#39;: 2, &#39;is&#39;: 1, &#39;this&#39;: 1, &#39;there&#39;: 1, &#39;a&#39;: 1})
&gt;&gt;&gt;
</pre></div>
<p>Now <code>counts</code> is a Counter object. It behaves a lot like a dictionary,
and everything that works with a dictionary should also work with a
counter. We can also convert the counter to a dictionary by doing
<code>dict(the_counter)</code> if something doesn't work with a counter.</p>
<div class="highlight" style="background: #111111"><pre style="line-height: 125%; margin: 0;"><span></span>&gt;&gt;&gt; <span style="color: #6699cc; font-weight: bold">for</span> word, count in counts.items():
...     <span style="color: #9966ff">print</span>(word, count)
...
test 2
is 1
this 1
there 1
a 1
hello 2
&gt;&gt;&gt;
</pre></div>
<a name="combining-dictionaries" href="#combining-dictionaries"><h2>Combining dictionaries</h2>
</a><p>We can add together strings, lists, tuples and sets easily.</p>
<div class="highlight" style="background: #111111"><pre style="line-height: 125%; margin: 0;"><span></span>&gt;&gt;&gt; <span style="color: #ffff33">&quot;hello&quot;</span> + <span style="color: #ffff33">&quot;world&quot;</span>
&#39;helloworld&#39;
&gt;&gt;&gt; [1, 2, 3] + [4, 5]
[1, 2, 3, 4, 5]
&gt;&gt;&gt; (1, 2, 3) + (4, 5)
(1, 2, 3, 4, 5)
&gt;&gt;&gt; {1, 2, 3} | {4, 5}
{1, 2, 3, 4, 5}
&gt;&gt;&gt;
</pre></div>
<p>But how about dictionaries? They can't be added together with <code>+</code>.</p>
<div class="highlight" style="background: #111111"><pre style="line-height: 125%; margin: 0;"><span></span>&gt;&gt;&gt; {<span style="color: #ffff33">&#39;a&#39;</span>: 1, <span style="color: #ffff33">&#39;b&#39;</span>: 2} + {<span style="color: #ffff33">&#39;c&#39;</span>: 3}
Traceback (most recent call last):
  File <span style="color: #9966ff">&quot;&lt;stdin&gt;&quot;</span>, line 1, in &lt;module&gt;
TypeError: unsupported operand type(s) for +: &#39;dict&#39; and &#39;dict&#39;
&gt;&gt;&gt;
</pre></div>
<p>Usually it's easiest to do this:</p>
<div class="highlight" style="background: #111111"><pre style="line-height: 125%; margin: 0;"><span></span>&gt;&gt;&gt; dict1 = {<span style="color: #ffff33">&#39;a&#39;</span>: 1, <span style="color: #ffff33">&#39;b&#39;</span>: 2}
&gt;&gt;&gt; dict2 = {<span style="color: #ffff33">&#39;c&#39;</span>: 3}
&gt;&gt;&gt; {**dict1, **dict2}
{&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}
</pre></div>
<p>Dictionaries also have an <code>update</code> method that adds everything from another
dictionary into it, and you can use that too. This was the most common way to
do it before Python supported <code>{**dict1, **dict2}</code>.</p>
<div class="highlight" style="background: #111111"><pre style="line-height: 125%; margin: 0;"><span></span>&gt;&gt;&gt; merged = {}
&gt;&gt;&gt; merged.update({<span style="color: #ffff33">&#39;a&#39;</span>: 1, <span style="color: #ffff33">&#39;b&#39;</span>: 2})
&gt;&gt;&gt; merged.update({<span style="color: #ffff33">&#39;c&#39;</span>: 3})
&gt;&gt;&gt; merged
{&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}
&gt;&gt;&gt;
</pre></div>
<a name="summary" href="#summary"><h2>Summary</h2>
</a><ul>
<li>Duck typing means requiring some behavior instead of some type. For
example, instead of making a function that takes a list we could make
a function that takes anything <a href="../basics/loops.html#summary">iterable</a>.</li>
<li>Sets and the collections module are handy. Use them.</li>
</ul>
<hr>
<p>If you have trouble with this tutorial please <a href="../contact-me.html">tell me about
it</a> and I'll make this tutorial better. If you
like this tutorial, please <a href="../index.html#how-can-i-thank-you-for-writing-and-sharing-this-tutorial">give it a
star</a>.</p>
<p>You may use this tutorial freely at your own risk. See
<a href="../LICENSE.txt">LICENSE</a>.</p>
<p><a href="../basics/docstrings.html">Previous</a> | <a href="functions.html">Next</a> |
<a href="../index.html#advanced">List of contents</a></p>

  </body>
</html>

